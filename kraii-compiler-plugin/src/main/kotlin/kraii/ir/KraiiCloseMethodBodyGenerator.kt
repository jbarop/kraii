package kraii.ir

import kraii.KraiiPluginKey
import kraii.api.Scoped
import kraii.closeName
import org.jetbrains.kotlin.backend.common.extensions.IrPluginContext
import org.jetbrains.kotlin.backend.common.lower.DeclarationIrBuilder
import org.jetbrains.kotlin.builtins.StandardNames
import org.jetbrains.kotlin.descriptors.DescriptorVisibilities
import org.jetbrains.kotlin.ir.IrElement
import org.jetbrains.kotlin.ir.IrStatement
import org.jetbrains.kotlin.ir.UNDEFINED_OFFSET
import org.jetbrains.kotlin.ir.builders.IrBuilderWithScope
import org.jetbrains.kotlin.ir.builders.declarations.buildFun
import org.jetbrains.kotlin.ir.builders.irCall
import org.jetbrains.kotlin.ir.builders.irGet
import org.jetbrains.kotlin.ir.declarations.*
import org.jetbrains.kotlin.ir.expressions.IrBlockBody
import org.jetbrains.kotlin.ir.expressions.IrStatementOrigin
import org.jetbrains.kotlin.ir.expressions.impl.IrFunctionExpressionImpl
import org.jetbrains.kotlin.ir.symbols.IrSimpleFunctionSymbol
import org.jetbrains.kotlin.ir.symbols.impl.IrValueParameterSymbolImpl
import org.jetbrains.kotlin.ir.types.IrType
import org.jetbrains.kotlin.ir.types.classFqName
import org.jetbrains.kotlin.ir.types.typeOrNull
import org.jetbrains.kotlin.ir.types.typeWith
import org.jetbrains.kotlin.ir.util.kotlinFqName
import org.jetbrains.kotlin.ir.util.patchDeclarationParents
import org.jetbrains.kotlin.ir.util.properties
import org.jetbrains.kotlin.ir.visitors.IrVisitorVoid
import org.jetbrains.kotlin.ir.visitors.acceptChildrenVoid
import org.jetbrains.kotlin.name.CallableId
import org.jetbrains.kotlin.name.FqName
import org.jetbrains.kotlin.name.Name

/**
 * Generates the body of the [AutoCloseable.close] method.
 * Closes all properties annotated with @Scoped in reverse declaration order.
 */
class KraiiCloseMethodBodyGenerator(
  private val pluginContext: IrPluginContext,
) : IrVisitorVoid() {

  private val irFactory = pluginContext.irFactory
  private val irBuiltIns = pluginContext.irBuiltIns

  override fun visitElement(element: IrElement) {
    when (element) {
      is IrDeclaration,
      is IrFile,
      is IrModuleFragment -> element.acceptChildrenVoid(this)
      else -> {}
    }
  }

  override fun visitSimpleFunction(declaration: IrSimpleFunction) {
    if (declaration.name != closeName) return

    val irClass = declaration.parent as? IrClass ?: return

    val origin = declaration.origin
    val isGeneratedByUs = origin is IrDeclarationOrigin.GeneratedByPlugin && origin.pluginKey == KraiiPluginKey

    if (isGeneratedByUs) {
      // Generated by our plugin: create the full body
      declaration.body = generateCloseBody(declaration, irClass, existingStatements = emptyList<IrStatement>())
    } else {
      // Existing user-defined method: append cleanup code to existing body
      val existingBody = declaration.body as? IrBlockBody ?: return
      declaration.body = generateCloseBody(declaration, irClass, existingStatements = existingBody.statements)
    }
  }

  private fun generateCloseBody(
    closeFunction: IrSimpleFunction,
    irClass: IrClass,
    existingStatements: List<IrStatement>,
  ): IrBlockBody {
    val builder = DeclarationIrBuilder(pluginContext, closeFunction.symbol)
    val statements = mutableListOf<IrStatement>()

    // Preserve existing statements first
    statements.addAll(existingStatements)

    val propertiesToClose = irClass.properties
      .filter { it.isAnnotatedWith(Scoped::class) }
      .toList()
      .reversed()

    val thisReceiver = closeFunction.dispatchReceiverParameter!!

    for (property in propertiesToClose) {
      val propertyType = property.type

      if (propertyType.implements(AutoCloseable::class)) {
        // Direct AutoCloseable: call property.close()
        val getter = property.getter ?: continue
        val closeMethod = propertyType.functionByName("close") ?: continue

        val getProperty = builder.irCall(getter, origin = IrStatementOrigin.GET_PROPERTY).apply {
          dispatchReceiver = builder.irGet(thisReceiver)
        }

        val callClose = builder.irCall(closeMethod).apply {
          dispatchReceiver = getProperty
        }

        statements.add(callClose)

      } else if (propertyType.implements(Iterable::class)) {
        // Iterable<AutoCloseable>: call property.reversed().forEach { it.close() }
        val getter = property.getter ?: continue
        val elementType = propertyType.arguments.first().typeOrNull ?: continue

        val getProperty = builder.irCall(getter, origin = IrStatementOrigin.GET_PROPERTY).apply {
          dispatchReceiver = builder.irGet(thisReceiver)
        }

        // property.reversed()
        val reversedCall = builder.irCall(iterableReversedSymbol).apply {
          arguments[0] = getProperty  // Extension receiver at index 0 for top-level extension
        }

        // Create lambda: { it: T -> it.close() }
        val lambda = builder.createCloseLambda(elementType)

        // .forEach(lambda)
        val forEachCall = builder.irCall(iterableForEachSymbol).apply {
          arguments[0] = reversedCall  // Extension receiver at index 0
          typeArguments[0] = elementType
          arguments[1] = IrFunctionExpressionImpl(  // Lambda is the second argument
            startOffset = UNDEFINED_OFFSET,
            endOffset = UNDEFINED_OFFSET,
            type = createFunctionType(elementType),
            function = lambda,
            origin = IrStatementOrigin.LAMBDA,
          ).also {
            lambda.patchDeclarationParents(closeFunction)
          }
        }

        statements.add(forEachCall)
      }
    }

    return irFactory.createBlockBody(UNDEFINED_OFFSET, UNDEFINED_OFFSET, statements)
  }

  @Suppress("DEPRECATION")
  private fun IrBuilderWithScope.createCloseLambda(
    elementType: IrType,
  ): IrSimpleFunction {
    val closeMethod = elementType.functionByName("close")
      ?: error("close() method not found on $elementType")

    return irFactory.buildFun {
      name = Name.special("<anonymous>")
      returnType = irBuiltIns.unitType
      origin = IrDeclarationOrigin.LOCAL_FUNCTION_FOR_LAMBDA
      visibility = DescriptorVisibilities.LOCAL
    }.apply {
      val itParam = irFactory.createValueParameter(
        startOffset = UNDEFINED_OFFSET,
        endOffset = UNDEFINED_OFFSET,
        origin = IrDeclarationOrigin.DEFINED,
        kind = IrParameterKind.Regular,
        name = Name.identifier("it"),
        type = elementType,
        isAssignable = false,
        symbol = IrValueParameterSymbolImpl(),
        varargElementType = null,
        isCrossinline = false,
        isNoinline = false,
        isHidden = false,
      ).also { it.parent = this }

      parameters = listOf(itParam)

      body = irFactory.createBlockBody(
        UNDEFINED_OFFSET,
        UNDEFINED_OFFSET,
        listOf(
          irCall(closeMethod).apply {
            dispatchReceiver = irGet(itParam)
          }
        )
      )
    }
  }

  private fun createFunctionType(paramType: IrType): IrType {
    val functionClass = pluginContext.referenceClass(StandardNames.getFunctionClassId(1))
      ?: error("Cannot find Function1 class")
    return functionClass.typeWith(paramType, irBuiltIns.unitType)
  }

  private val iterableForEachSymbol: IrSimpleFunctionSymbol by lazy {
    pluginContext.referenceFunctions(
      CallableId(FqName("kotlin.collections"), Name.identifier("forEach"))
    ).single {
      it.owner.parameters.find { p -> p.kind == IrParameterKind.ExtensionReceiver }
        ?.type?.classFqName == irBuiltIns.iterableClass.owner.kotlinFqName
    }
  }

  private val iterableReversedSymbol: IrSimpleFunctionSymbol by lazy {
    pluginContext.referenceFunctions(
      CallableId(FqName("kotlin.collections"), Name.identifier("reversed"))
    ).single {
      it.owner.parameters.find { p -> p.kind == IrParameterKind.ExtensionReceiver }
        ?.type?.classFqName == irBuiltIns.iterableClass.owner.kotlinFqName
    }
  }
}
